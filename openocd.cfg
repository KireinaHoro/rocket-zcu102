#
# Digilent JTAG-SMT2
#
# http://www.digilentinc.com/Products/Detail.cfm?NavPath=2,395,1053&Prod=JTAG-SMT2
#
# Config is based on data from
# http://electronix.ru/forum/index.php?showtopic=114633&view=findpost&p=1215497 and ZedBoard schematics
#

adapter_khz 50000

interface ftdi
ftdi_vid_pid 0x0403 0x6014

ftdi_layout_init 0x2088 0x3f8b
ftdi_layout_signal nSRST -data 0x2000
ftdi_layout_signal GPIO2 -data 0x2000
ftdi_layout_signal GPIO1 -data 0x0200
ftdi_layout_signal GPIO0 -data 0x0100

ftdi_tdo_sample_edge falling
reset_config none

bindto 192.168.79.129

#
# target configuration for
# Xilinx ZynqMP (UltraScale+ / A53)
#
if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME uscale
}

#
# DAP tap (Quard core A53)
#
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    set _DAP_TAPID 0x5ba00477
}

jtag newtap $_CHIPNAME tap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.tap

#
# PS tap (UltraScale+)
#
if { [info exists PS_TAPID] } {
    set _PS_TAPID $PS_TAPID
    jtag newtap $_CHIPNAME ps -irlen 12 -ircapture 0x1 -irmask 0x03 -expected-id $_PS_TAPID
} else {
    # FPGA Programmable logic. Values take from Table 39-1 in UG1085:
    jtag newtap $_CHIPNAME ps -irlen 12 -ircapture 0x1 -irmask 0x03 -ignore-version \
        -expected-id 0x04711093 \
        -expected-id 0x04710093 \
        -expected-id 0x04721093 \
        -expected-id 0x04720093 \
        -expected-id 0x04739093 \
        -expected-id 0x04730093 \
        -expected-id 0x04738093 \
        -expected-id 0x04740093 \
        -expected-id 0x04750093 \
        -expected-id 0x04759093 \
        -expected-id 0x04758093
}

set jtag_configured 0

jtag configure $_CHIPNAME.ps -event setup {
    global _CHIPNAME
    global jtag_configured

    if { $jtag_configured == 0 } {
        # add the DAP tap to the chain
        # See https://forums.xilinx.com/t5/UltraScale-Architecture/JTAG-Chain-Configuration-for-Zynq-UltraScale-MPSoC/td-p/758924
        irscan $_CHIPNAME.ps 0x824
        drscan $_CHIPNAME.ps 32 0x00000003
        runtest 100

        # setup event will be re-entered through jtag arp_init
        # break the recursion
        set jtag_configured 1
        # re-initialized the jtag chain
        jtag arp_init
    }
}

# ARM Cortex-A53 targets
proc init_arm {} {
    global _CHIPNAME
    set _TARGETNAME $_CHIPNAME.a53
    set _CTINAME $_CHIPNAME.cti
    set _smp_command ""

    set DBGBASE {0x80410000 0x80510000 0x80610000 0x80710000}
    set CTIBASE {0x80420000 0x80520000 0x80620000 0x80720000}
    set _cores 4

    for { set _core 0 } { $_core < $_cores } { incr _core } {

        cti create $_CTINAME.$_core -dap $_CHIPNAME.dap -ap-num 1 \
            -ctibase [lindex $CTIBASE $_core]

        set _command "target create $_TARGETNAME.$_core aarch64 -dap $_CHIPNAME.dap \
            -dbgbase [lindex $DBGBASE $_core] -cti $_CTINAME.$_core"

        if { $_core != 0 } {
            # non-boot core examination may fail
            set _command "$_command -defer-examine"
            set _smp_command "$_smp_command $_TARGETNAME.$_core"
        } else {
            # uncomment when "hawt" rtos is merged
            #set _command "$_command -rtos hawt"
            set _smp_command "target smp $_TARGETNAME.$_core"
        }

        eval $_command
    }

    eval $_smp_command
}

# RISC-V targets through BSCAN tunneling
proc init_riscv {} {
    global _CHIPNAME
    set _TARGETNAME $_CHIPNAME.riscv
    set _smp_command ""

    set WORKPHYSBASE {0x83000000}
    set _cores 1

    for { set _core 0 } { $_core < $_cores } { incr _core } {
        set _command "target create $_TARGETNAME.$_core riscv -chain-position $_CHIPNAME.ps \
            -work-area-phys [lindex $WORKPHYSBASE $_core] -work-area-size 0x10000 -work-area-backup 1"
        
        if { $_core != 0 } {
            set _command "$_command -defer-examine"
            set _smp_command "$_smp_command $_TARGETNAME.$_core"
        } else {
            set _smp_command "target smp $_TARGETNAME.$_core"
        }

        eval $_command
    }

    eval $_smp_command

    # Note: need USER4 to be 0x923 ( {0x23, 0x09} ) instead of the default 0x23 ( { 0x23 } )
    # https://github.com/KireinaHoro/riscv-openocd/commit/cb7f6be16f56a62fc1bdafe0030862e42446e6b2
    riscv use_bscan_tunnel 5

    # force using hardware breakpoints
    gdb_breakpoint_override hard

    puts "Initializing..."
    init

    # RISC-V DTM auth
    puts "Authenticating with RISC-V DTM..."
    set challenge [riscv authdata_read]
    riscv authdata_write [expr $challenge + 1]
    puts "Authentication succeeded."
}

proc core_up { target args } {
    foreach { core } [set args] {
        $target.$core arp_examine
    }
}
